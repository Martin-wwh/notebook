# Mysql组成

1. Mysql的组成
   
   Mysql组成分为两大部分，一部分是`Server`端，一部分是引擎端，Server端中主要包括了**连接器、分析器、优化器、执行器**，在Server端中还有一个查询缓存，以语句为key，查询结果为value，针对配置类库可以打开此选项，引擎端就是我们常说的innodb,myIsam。
   
   ![](http://47.114.144.122/\images\2020-10-12-14-58-57-image.png)
   
   - 优化器
     
     <mark>Mysql优化器是如何选择一个正确的索引的？</mark>
     
     在数据库里面，扫描行数是影响执行效率的关键部分，扫描的行数越少，访问磁盘的次数就越少，Cpu执行的时间就越短。当然扫描行数并非唯一指标，优化器还会结合是否采用临时表、是否排序等因素。
     
     **优化器是如何知道扫描行数的？**
     
     Mysql在真正执行之前是不知道具体要扫描多少行的，他采用的是一种统计数据，即索引的<mark>区分度</mark>。针对每个索引，它会随机抽取N个数据页，统计每个数据页中不同值的个数，得到一个平均值，然后乘以这个索引的页数，得到一个<mark>基数</mark>。基数越大，区分度越高。
   
   - 执行器
     
     sql在执行的过程中会有不同的临时中间表，一般是按照如下顺序
     
     - From
     
     - ON
     
     - join
     
     - where
     
     - group by
     
     - WITH CUBE 或 WITH ROLLUP
     
     - having
     
     - select
     
     - distinct
     
     - order by
     
     - top

2. mysql引擎
   
   - myisam vs innodb
     
     myisam是5.1版本之前的默认引擎，支持全文搜索、压缩和空间函数等。但是不支持行锁和事务。多应用于多查询少插入的场景。而且myisam不支持外键，并且索引和数据是分开存储的。
     
     innodb是基于聚簇索引建立的，与myisam相反的是，它支持事务，行锁，外键，通过MVCC执行多版本高并发控制，索引和数据放在一起。

# 日志

1. binlog详解
   
   1. binlog的三种工作模式：
      
      - statement（**默认**）: 记录的是修改sql的语句
        
        优点：解决了row模式下数据量庞大的问题，减少了日志量
        
        缺点：容易导致主从不一致。（在主从同步下不建议用statement模式，因为有些语句不支持，比如UUID函数，以及LOAD DATA IN FILE语句等）
      
      - row: 记录的是每行实际数据的变更
        
        优点：记录每行数据被修改的情况，然后在slave端修改
        
        缺点：数据量太大
      
      - mix: statement和row形式的混合

2. redo log 与 binlog
   
   - Redo log是物理日志，记录的是在某个数据页上做了什么修改，binlog是逻辑日志，记录的是对ID=2的记录做了什么操作。
   
   - Redo log是innodb专有的日志文件，binlog是server端通用的
   
   - Redo log是循环写入的，当写满了之后需要刷到硬盘，binlog是追加的形式，到达一定的大小就会重新建一个文件

3. redo log 双段提交
   
   ![](http://47.114.144.122/images\2020-10-12-15-54-07-image.png)

# 事务

   事务是保证一系列操作的一致性，即事务内的操作要么全部生效，要么全部回滚。

   事务的特性：<mark>ACID</mark>

   A： atomicity 原子性 

   C： consistency 一致性

   I ： Isolation 隔离性

   D : durablity 持久性

1. 隔离性
   
   隔离级别有四种，安全性从低到高为：读未提交  -> 读提交 -> 可重复读 -> 串行化。
   
   **Mysql默认的隔离级别是可重复读。**
   
   <mark>为什么Mysql的默认级别是可重复读？</mark>
   
   在mysql5.1之前，binlog是不支持row形式的，只支持statement形式，在RC隔离级别下statement形式的binlog会导致主从不一致的问题。如下图
   
   ![](http://47.114.144.122/images\2020-10-12-16-23-22-image.png)
   
   在master中，最后的结果是存在3这条记录的，也就是先删后加的，但是在statement中是先加后删的，因此，他是不存在这条增加的记录的。
   
   因此，在RC条件下，mysql的binlog需要开启row模式。
   
   <mark>为什么在互联网项目中推荐使用RC隔离级别呢？</mark>
   
   主要原因有几个方面：
   
   - RR隔离级别由于存在间隙锁，会增加出现死锁的概率。
   
   - RR级别在未命中索引的情况下会导致锁表，RC只会锁行。
     
     在未命中索引的情况下，走聚簇索引，RC在检查不满足条件的情况下，会调用unlock_row方法解除扫描过程中的行锁。RR不会，同时会加上间隙锁，导致全表被锁住。
   
   - RC隔离级别下，半一致性读特性增加了update操作的并发性。

2. 事务隔离的原理
   
   在可重复读及读提交的隔离级别下，数据库会在不同的阶段创建一个视图，访问的时候以视图的逻辑结果为准。可重复读实在事务启动时创建，读提交是在每个SQL开始时创建。读未提交直接返回记录的最新值，串行化是通过加锁的方式来避免并行访问。

3. MVCC机制
   
   MVCC是多版本并发控制，实际上是保存了数据在某个时间节点的快照。
   
   每行数据都隐藏了两列，创建时间版本号，过期（删除）时间版本号，每创建一个事务，版本号都会增加。
   
   **MVCC的原理是查询创建时间版本小于或等于当前版本号的或者删除时间版本为null或者大于当前版本的数据。**

# 索引

1. 索引模型 B+树
   
   - hash 结构
     
     hash表结构比较简单，针对同一个key以链表的形式展现，但是数据量打大了之后就会影响整体的查询效率。同时他不能保证顺序性。
   
   - 有序数据
     
     在等值查询及范围查询的性能都比较优秀，但是只适合存储静态的数据，增加和删除效率低。
   
   - B+树
     
     B+树是由平衡二叉树演变而来，主要特征如下：
     
     - 所有数据都存储在叶子节点中，非叶子节点作为索引存在
     
     - B+数的叶子节点以双向链表的形式连接，这样做的目的是为了支持范围查询

2. 聚簇索引和非聚簇索引（二级索引 innodb）
   
   **聚簇索引**：这种数据和索引在一起存储的索引方式叫做聚簇索引，一张表只能有一个聚簇索引即为主键。
   
   **非聚簇索引**：非聚簇索引的叶子节点中存储的就是主键的值。

3. 索引覆盖和回表
   
   **索引覆盖**： 如果索引包含查询中的所有字段，那么就不需要执行回表查询，这种情况称为索引覆盖。
   
   回表查询指的是在命中非聚簇索引的情况下，索引中不能满足所有字段，那么就需要从聚簇索引中去获取相应的记录。

# 锁

1. mysql 锁的类型
   
   mysql锁主要分为**共享锁**和**排他锁**，即读锁和写锁。
   
   读锁是共享的，可以通过`lock in share mode`实现。
   
   写锁是排他的，可以分为行锁和表锁两部分。

2. RR隔离级别下间隙锁
   
   间隙锁之间是**不存在锁冲突**的，与间隙锁冲突的是往这个**间隙中插入一条新的数据**这个操作。
   
   间隙锁与行锁合称为**next-key lock**，每个next-key lock都是前开后闭的。
   
   mysql 加锁的两个**原则**，与两个**优化**：
   
   - 原则1：加锁的基本单位是next-key lock，是前开后闭的区间
   
   - 原则2：查找过程中访问到的对象才会加锁
   
   - 优化1：**索引**上的**等值操作**，给唯一索引加锁时，next-key lock 退化为行锁。
   
   - 优化2：**索引**上的等值查询，向右遍历且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。

# 分布式

1. 分表分库
   
   - 垂直分库：按照业务划分，将数据库划分为不同的模块。
   
   - 水平分库：把同一个表的数据按照一定规则拆到不同的数据库中，每个数据库放在不同的服务器上。
   
   - 垂直分表：将数据的访问频次，数据大小等特性不一样的数据进行拆分。
   
   - 水平分表：由于单表数据庞大，可以将表数据照一定的规则拆分到多个表中。
     
     根据业务场景，来决定使用什么字段来作为分表字段(sharding_key)，譬如C端应用，通过将user_id进行hash，存储到不同的表中。
   
   **分表之后表ID怎么保证唯一性？**
   
   - 设定步长，比如1-1024张表，那么，每个表对应的步长就是1-1024
   
   - 分布式ID，自己实现一套分布式id的创建算法，或者使用开源的比如雪花算法这种
   
   - 不使用表的主键作为查询依据，可以新增一个唯一字段，譬如订单ID作为查询依据。
   
   **分表后非sharing_key的查询怎么处理？**
   
   - 针对非sharing_key的查询建立映射表
   
   - 打宽表
   
   - 多线程扫表，然后聚合结果

2. 主从同步
   
   **原理**：
   
   - master提交完事务后，写入binlog
   
   - slave连接到master，获取binlog
   
   - master创建dump线程，推送binlog到slave
   
   - slave启动一个IO线程读取同步过来的master的binlog，记录到relay log中继日志中
   
   - slave再开启一个sql线程读取relay log事件并在slave执行，完成同步
   
   - slave记录自己的binlog
   
   流程图
   
   ![](http://47.114.144.122/images\2020-10-21-19-20-09-image.png)
   
   mysql的binlog的同步是异步的，因此master是否需要等待丛库同步，分为两种同步方式：
   
   - 全同步复制
     
     主库写入binlog后强制同步到丛库，所有丛库都写完毕之后才返回给客户端，这样性能很差
   
   - 半同步复制
     
     丛库写入日志成功之后发送ack消息给master，master只要收到一条ack就返回给客户端。

3. Redis 中 sentinel模式
   
   哨兵模式通过发送命令，等待redis服务器响应，来监听运行的多个redis实例的运行状态。
   
   **哨兵的三个定时任务：**
   
   - 哨兵每10s会向主节点和从节点发送info命令获取最新的拓扑结构图，哨兵配置只需配置主节点的监控，通过向主节点发送info，获取从节点的信息，有新节点加入可以马上感知。
   
   - 哨兵节点每隔2s会向redis数据节点的指定频道上（_sentinel_: hello）发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，每个哨兵节点会订阅该频道，来了解其他哨兵的信息以及对主节点的判断。
   
   - 每隔1s每个哨兵会向主节点，从节点以及哨兵发送ping命令，做心跳检测。
   
   单哨兵的缺点，当由于网络波动，或该进程出现错误，那么主从切换的功能就变得不可用。因此，我们需要多哨兵节点来对redis集群进行管理。
   
   **故障切换（fail-over）的过程：**
   
   假设master宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观认为master不可用，这被称为**主观下线**。
   
   当后面的哨兵也检测到主服务器不可用，当发现的哨兵数达到一定数量时（一半以上），则认为该节点客观下线，并进行failover。
   
   **选举领头sentinel**
   
   - 每个sentinel发现master客观下线之后，都会要求其他sentinel节点将自己设为领导者。
   
   - 当一个sentinel已经设置了leader，后续设置leader的请求都将被拒绝
   
   - 当一个sentinel被半数以上的sentinel设置为leader，那么该节点就是leader，将执行master的故障转移。
   
   - 限定时间未选出leader，就会进行下一次选举。
   
   **sentinel机制**
   
   - sentinel没有自动删除的功能，sentinel节点删除需要手动让每个sentinel reset。
   
   - sentinel会永远记录一个Master的所有slave节点，即使发生failover后，当slave恢复时，也可以从新的master复制数据。
   
   **slave选举与优先级**
   
   主要考虑方面有以下几点：
   
   - 与master断开连接次数
   
   - Slave的优先级
   
   - 数据复制的下标（用来评估当前slave与master的同步率）
   
   - 进程ID
   
   slave的优先级越小排名越靠前，相同优先级的比对数据的同步率，都一样就比对进程ID。
